<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.9.19">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="An edition of Bram Stoker’s Dracula that presents the original text alongside computational analyses and visualizations of it.">

<title>5&nbsp; Dracula — Lemmatized Term-Frequency (Pyodide + precomputed chap_lemmas.csv) – Dracula</title>
<style>
/* Default styles provided by pandoc.
** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
*/
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./99-text-analysis.html" rel="prev">
<link href="./Dracula_cover.jpg" rel="icon" type="image/jpeg">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/tabby.min.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-3f61aac59b63c3a2d0e87c59ee7d0662.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-4b5ef9857656f9b6774e3fa0af6052bd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": true,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>


<meta property="og:title" content="5&nbsp; Dracula — Lemmatized Term-Frequency (Pyodide + precomputed chap_lemmas.csv) – Dracula">
<meta property="og:description" content="An edition of Bram Stoker’s Dracula that presents the original text alongside computational analyses and visualizations of it.">
<meta property="og:image" content="https://iulibscholcomm.github.io/dracula/Dracula_cover.jpg">
<meta property="og:site_name" content="Dracula">
<meta property="og:image:alt" content="book cover of Dracula with a yellow background and red title, author, and border">
<meta name="twitter:title" content="5&nbsp; Dracula — Lemmatized Term-Frequency (Pyodide + precomputed chap_lemmas.csv) – Dracula">
<meta name="twitter:description" content="An edition of Bram Stoker’s Dracula that presents the original text alongside computational analyses and visualizations of it.">
<meta name="twitter:image" content="https://iulibscholcomm.github.io/dracula/Dracula_cover.jpg">
<meta name="twitter:image:alt" content="book cover of Dracula with a yellow background and red title, author, and border">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar docked quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./dracula-lemmata-pyodide.html"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Dracula — Lemmatized Term-Frequency (Pyodide + precomputed chap_lemmas.csv)</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      <img src="./Dracula_cover.jpg" alt="book cover of Dracula with a yellow background and red title, author, and border" class="sidebar-logo light-content py-0 d-lg-inline d-none">
      <img src="./Dracula_cover.jpg" alt="book cover of Dracula with a yellow background and red title, author, and border" class="sidebar-logo dark-content py-0 d-lg-inline d-none">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Dracula</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/IULibScholComm/dracula" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./note.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Note</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Jonathan Harker’s Journal</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Jonathan Harker’s Journal–<em>continued</em></span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Jonathan Harker’s Journal (<em>continued</em>)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./99-text-analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Text analysis: Dracula</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./dracula-lemmata-pyodide.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Dracula — Lemmatized Term-Frequency (Pyodide + precomputed chap_lemmas.csv)</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    <div class="quarto-code-links"><h2>Code Links</h2><ul><li><a href="https://mybinder.org/v2/gh/IULibScholComm/dracula/HEAD?urlpath=vscode" target="_blank"><i class="bi bi-journals"></i>Launch Binder</a></li></ul></div></div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Dracula — Lemmatized Term-Frequency (Pyodide + precomputed chap_lemmas.csv)</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div style="max-width:900px">
<p>
Enter a single <strong>lemmatized</strong> word (no multi-word phrases). Example: <code>vampire</code>
</p>
<p><label for="lemma">Lemma:</label> <input id="lemma" placeholder="vampire" style="width:220px"> <button id="plotBtn">Plot</button> <label style="margin-left:12px"><input type="checkbox" id="normalize"> Normalize (per 1k words)</label></p>
<!-- status is now an ARIA live region -->
<div id="status" style="margin-top:8px;color:#666" aria-live="polite" role="status">
Status: initializing…
</div>
<div id="plotArea" style="margin-top:12px">

</div>
<p style="color:#666; margin-top:14px; font-size:0.95em">
If you want full spaCy-powered searches or NER, run the original notebook in Binder/Colab; this page is designed for lightweight in-browser lemmatized lookups using a precomputed CSV.
</p>
</div>
<script type="module">
/* Unified Pyodide script with accessibility outputs + trend calculation */

const CSV_CANDIDATES = [
  "https://iulibscholcomm.github.io/dracula/data/chap_lemmas.csv",
  "/dracula/data/chap_lemmas.csv",
  "/data/chap_lemmas.csv",
  "data/chap_lemmas.csv",
  "chap_lemmas.csv"
];

const statusEl = document.getElementById("status");
const plotEl = document.getElementById("plotArea");
const plotBtn = document.getElementById("plotBtn");
const lemmaInput = document.getElementById("lemma");
const normalizeBox = document.getElementById("normalize");

let pyodide = null;
let pyReady = false;
let csvTextCache = null;
let pyState = null; // { df_proxy, counters_proxy, source }

// ---------- Python snippets ----------
// Initialization (unchanged except variable names preserved)
const initPyGlobals = `
import io, pandas as pd
from collections import Counter

# csv_text is injected by JS
if 'csv_text' not in globals() or csv_text is None:
    raise ValueError("csv_text not provided or is None.")

# Read CSV robustly
try:
    df = pd.read_csv(io.StringIO(csv_text), encoding='utf-8')
except Exception as e:
    preview = (csv_text or "")[:1000]
    raise ValueError(f"pd.read_csv failed: {e}\\nPreview (first 1000 chars):\\n{preview}")

# Validate minimal columns
required = ['chapter','lemmas_str','word_count']
missing = [c for c in required if c not in df.columns]
if missing:
    raise ValueError("Missing columns in chap_lemmas.csv: " + ",".join(missing))

# Normalize types and fillna
df['chapter'] = pd.to_numeric(df['chapter'], errors='coerce').fillna(0).astype(int)
df['lemmas_str'] = df.get('lemmas_str', '').fillna("").astype(str)
df['word_count'] = pd.to_numeric(df.get('word_count', 0), errors='coerce').fillna(0).astype(int)

# Build counters per row
chapter_counters = []
for s in df['lemmas_str'].tolist():
    if not s:
        chapter_counters.append(Counter())
    else:
        chapter_counters.append(Counter(s.split()))

# Expose to JS via pyodide.globals
chap_df = df
chapter_counters = chapter_counters

# readiness
"OK"
`;

/* Plot template now returns a tuple: (base64_png, out_json)
   out_json includes numeric arrays and a short trend sentence computed
   using linear slope + Pearson r (numpy). */
const plotPyTemplate = `
import io, base64, matplotlib, json
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np

# injected by JS: df, counters, query, normalize_flag
q = query.strip().lower()
if not q:
    raise ValueError("Empty query")

# get counts per chapter
try:
    counts = [int(c.get(q, 0)) for c in counters]
except Exception as e:
    raise ValueError("Error iterating counters: " + str(e))

lengths = [int(x) for x in df['word_count'].tolist()]
arr = np.array(counts, dtype=float)

# normalized series (per 1k words) if requested
if normalize_flag:
    lens = np.array(lengths, dtype=float)
    lens[lens==0] = 1.0
    arr_norm = (arr / lens * 1000.0)
    series_for_trend = arr_norm
else:
    arr_norm = None
    series_for_trend = arr

# simple trend calculation using linear regression and Pearson r
trend_text = ""
if len(series_for_trend) >= 2:
    x = np.arange(1, len(series_for_trend)+1, dtype=float)
    # fit linear slope (y = a*x + b)
    a, b = np.polyfit(x, series_for_trend, 1)
    # Pearson correlation
    try:
        r = float(np.corrcoef(x, series_for_trend)[0,1])
    except Exception:
        r = 0.0

    # interpret: thresholds are heuristic
    if abs(r) >= 0.4:
        if a > 0:
            trend_text = f"Increasing trend (slope={a:.3f}, r={r:.2f})."
        else:
            trend_text = f"Decreasing trend (slope={a:.3f}, r={r:.2f})."
    elif abs(r) >= 0.2:
        if a > 0:
            trend_text = f"Mild upward trend (slope={a:.3f}, r={r:.2f})."
        else:
            trend_text = f"Mild downward trend (slope={a:.3f}, r={r:.2f})."
    else:
        trend_text = f"No clear trend (slope={a:.3f}, r={r:.2f})."
else:
    trend_text = "Not enough points to compute trend."

# Plotting (visual for sighted users)
x = np.arange(1, len(arr)+1)
fig, ax = plt.subplots(figsize=(9,3))
ax.plot(x, arr, marker='o', linewidth=1)
ax.set_xlabel("Chapter")
ax.set_ylabel("Occurrences per 1k words" if normalize_flag else "Raw count")
ax.set_title(f"Frequency of '{query}' (lemmatized) — n_chapters={len(arr)}")
ax.grid(axis='y', alpha=0.3)
plt.tight_layout()
buf = io.BytesIO()
fig.savefig(buf, format='png', dpi=150)
plt.close(fig)
buf.seek(0)
b64 = base64.b64encode(buf.getvalue()).decode('ascii')

# Prepare numeric summary
arr_raw = arr.tolist()
arr_norm_list = arr_norm.tolist() if arr_norm is not None else None

total = int(np.sum(arr_raw))
max_val = None if len(arr_raw)==0 else int(np.max(arr_raw))
max_chapters = [] if max_val is None else [i+1 for i,v in enumerate(arr_raw) if int(v)==max_val]
min_val = None if len(arr_raw)==0 else int(np.min(arr_raw))
min_chapters = [] if min_val is None else [i+1 for i,v in enumerate(arr_raw) if int(v)==min_val]

out = {
    "query": query,
    "n_chapters": len(arr_raw),
    "counts_raw": arr_raw,
    "counts_norm": arr_norm_list,
    "word_counts": lengths,
    "total_raw": total,
    "max_raw": int(max_val) if max_val is not None else None,
    "max_chapters": max_chapters,
    "min_raw": int(min_val) if min_val is not None else None,
    "min_chapters": min_chapters,
    "trend_text": trend_text
}

out_json = json.dumps(out)
b64, out_json
`;

// ---------- Helpers ----------

async function loadPy() {
  statusEl.textContent = "Status: loading Pyodide (may take a few seconds)...";
  if (typeof loadPyodide !== "function") {
    const s = document.createElement("script");
    s.src = "https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js";
    document.head.appendChild(s);
    await new Promise(res => { s.onload = res; });
  }
  pyodide = await loadPyodide({ indexURL: "https://cdn.jsdelivr.net/pyodide/v0.23.4/full/" });
  statusEl.textContent = "Status: installing micropip & packages...";
  await pyodide.loadPackage(["micropip"]);
  const micropip = pyodide.pyimport("micropip");
  await micropip.install("pandas");
  await micropip.install("matplotlib");
  await pyodide.loadPackage(["numpy"]);
  statusEl.textContent = "Status: Python environment ready.";
  pyReady = true;
}

async function tryFetchCandidates(candidates) {
  for (const url of candidates) {
    statusEl.textContent = `Status: attempting to fetch ${url} ...`;
    try {
      const r = await fetch(url);
      if (!r.ok) {
        console.debug(`Candidate ${url} returned ${r.status}`);
        continue;
      }
      const txt = await r.text();
      statusEl.textContent = `Status: loaded ${url}`;
      return { url, text: txt };
    } catch (e) {
      console.debug(`Fetch ${url} failed:`, e);
      continue;
    }
  }
  throw new Error("All CSV fetch attempts failed.");
}

// ---------- Initialization ----------
(async () => {
  try {
    await loadPy();
  } catch (err) {
    console.error("Pyodide load failed:", err);
    statusEl.textContent = "Status: Pyodide load failed: " + String(err);
    return;
  }

  // fetch CSV text
  let csvResult = null;
  try {
    csvResult = await tryFetchCandidates(CSV_CANDIDATES);
  } catch (fetchErr) {
    console.error("CSV fetch attempts failed:", fetchErr);
    statusEl.textContent = "Status: failed to fetch chap_lemmas.csv. Place file under docs/data and/or update CSV_CANDIDATES.";
    return;
  }

  csvTextCache = csvResult.text || "";
  statusEl.textContent = `Status: building Python state from ${csvResult.url}...`;

  try {
    pyodide.globals.set("csv_text", csvTextCache);
    const ok = await pyodide.runPythonAsync(initPyGlobals);
    try { pyodide.globals.delete("csv_text"); } catch (e) {}
    if (ok !== "OK") {
      console.warn("Python init returned:", ok);
    }

    const py_df = pyodide.globals.get("chap_df");
    const py_counters = pyodide.globals.get("chapter_counters");

    if (!py_df || !py_counters) {
      console.error("Missing Python globals after init:", { py_df, py_counters });
      statusEl.textContent = "Status: Python init failed — chap_df or chapter_counters not set. See console.";
      return;
    }

    pyState = { df_proxy: py_df, counters_proxy: py_counters, source: csvResult.url };
    statusEl.textContent = `Status: ready (using ${csvResult.url}). Enter a lemmatized word and click Plot.`;
  } catch (pyErr) {
    console.error("Python initialization error:", pyErr);
    try { console.warn("CSV preview (first 800 chars):", (csvTextCache||"").slice(0,800)); } catch(e){}
    statusEl.textContent = "Status: Python initialization failed — see console for details.";
    return;
  }
})();

// ---------- Plotting function ----------
async function plotLemma(query, normalize) {
  if (!pyReady) {
    statusEl.textContent = "Status: Pyodide not ready.";
    return;
  }
  if (!pyState || !pyState.df_proxy || !pyState.counters_proxy) {
    statusEl.textContent = "Status: Python state not initialized. Try reloading the page.";
    console.error("plotLemma called but pyState is missing or malformed:", pyState);
    return;
  }

  statusEl.textContent = "Status: computing counts & plotting...";
  try {
    // inject handles expected by plot template
    pyodide.globals.set("df", pyState.df_proxy);
    pyodide.globals.set("counters", pyState.counters_proxy);
    pyodide.globals.set("query", query);
    pyodide.globals.set("normalize_flag", normalize);

    // run and receive tuple: (b64_png, out_json)
    const result = await pyodide.runPythonAsync(plotPyTemplate);

    // result behaves like an array-like proxy: index 0 -> b64 image, index 1 -> json string
    const b64 = result[0];
    const out_json = result[1];

    // cleanup injected globals
    try { pyodide.globals.delete("df"); } catch(e){}
    try { pyodide.globals.delete("counters"); } catch(e){}
    try { pyodide.globals.delete("query"); } catch(e){}
    try { pyodide.globals.delete("normalize_flag"); } catch(e){}

    // parse JSON safely
    let data = null;
    try {
      data = JSON.parse(out_json);
    } catch (e) {
      console.warn("Failed to parse out_json:", e, out_json);
      data = null;
    }

    // render image and accessible report
    plotEl.innerHTML = "";
    const img = document.createElement("img");
    img.src = "data:image/png;base64," + b64;
    img.alt = `Lemma frequency: ${query}`;
    img.style.maxWidth = "100%";
    img.tabIndex = 0; // keyboard focusable

    // accessible description region id
    const descId = "plot-desc-" + Math.random().toString(36).slice(2,9);
    img.setAttribute("aria-describedby", descId);

    plotEl.appendChild(img);

    // Create region that contains summary, CSV download, table
    const report = document.createElement("div");
    report.id = descId;
    report.style.marginTop = "10px";
    report.setAttribute("role", "region");
    report.setAttribute("aria-live", "polite");
    report.setAttribute("aria-label", `Numeric summary for ${query}`);
    plotEl.appendChild(report);

    if (data) {
      // trend sentence (from Python)
      const trendP = document.createElement("p");
      trendP.style.margin = "4px 0";
      trendP.textContent = data.trend_text || "";
      trendP.style.fontStyle = "italic";
      report.appendChild(trendP);

      // brief numeric summary
      const summaryP = document.createElement("p");
      summaryP.style.margin = "4px 0";
      const maxCh = (data.max_chapters || []).join(", ") || "N/A";
      const minCh = (data.min_chapters || []).join(", ") || "N/A";
      const total = (data.total_raw !== undefined) ? data.total_raw : "N/A";
      summaryP.textContent = `${data.n_chapters} chapters. Total occurrences (raw): ${total}. Highest raw count: ${data.max_raw} (chapter(s) ${maxCh}). Lowest raw count: ${data.min_raw} (chapter(s) ${minCh}).`;
      report.appendChild(summaryP);

      // CSV download
      const csvBtn = document.createElement("a");
      csvBtn.style.display = "inline-block";
      csvBtn.style.margin = "6px 0";
      csvBtn.textContent = "Download chapter counts (CSV)";
      csvBtn.setAttribute("role","button");
      csvBtn.setAttribute("aria-pressed","false");

      const csvLines = ["chapter,word_count,raw_count" + (data.counts_norm ? ",normalized_per_1k" : "")];
      for (let i=0;i<data.n_chapters;i++){
        const chap = i+1;
        const wc = (data.word_counts && data.word_counts[i]!==undefined) ? data.word_counts[i] : "";
        const raw = (data.counts_raw && data.counts_raw[i]!==undefined) ? data.counts_raw[i] : 0;
        const norm = (data.counts_norm && data.counts_norm[i]!==undefined) ? data.counts_norm[i] : "";
        csvLines.push([chap, wc, raw, norm].filter((_,idx)=> idx<3 || data.counts_norm).join(","));
      }
      const csvContent = csvLines.join("\n");
      const blob = new Blob([csvContent], {type:"text/csv"});
      const blobUrl = URL.createObjectURL(blob);
      csvBtn.href = blobUrl;
      csvBtn.download = `dracula_${query}_chapter_counts.csv`;
      report.appendChild(csvBtn);

      // Accessible table
      const table = document.createElement("table");
      table.style.width = "100%";
      table.style.borderCollapse = "collapse";
      table.style.marginTop = "8px";
      table.setAttribute("role", "table");
      table.setAttribute("aria-describedby", descId + "-caption");

      const caption = document.createElement("caption");
      caption.id = descId + "-caption";
      caption.style.textAlign = "left";
      caption.style.fontWeight = "600";
      caption.style.marginBottom = "4px";
      caption.textContent = `Chapter counts for lemma "${data.query}"`;
      table.appendChild(caption);

      const thead = document.createElement("thead");
      const hrow = document.createElement("tr");
      ["Chapter","Word count","Raw occurrences", normalize ? "Normalized per 1k words" : null].forEach(h=>{
        if (!h) return;
        const th = document.createElement("th");
        th.textContent = h;
        th.scope = "col";
        th.style.borderBottom = "1px solid #ccc";
        th.style.padding = "6px 4px";
        hrow.appendChild(th);
      });
      thead.appendChild(hrow);
      table.appendChild(thead);

      const tbody = document.createElement("tbody");
      for (let i=0;i<data.n_chapters;i++){
        const tr = document.createElement("tr");
        const chapCell = document.createElement("th");
        chapCell.scope = "row";
        chapCell.textContent = (i+1).toString();
        chapCell.style.padding = "6px 4px";
        tr.appendChild(chapCell);

        const wcCell = document.createElement("td");
        wcCell.textContent = (data.word_counts && data.word_counts[i]!==undefined) ? data.word_counts[i] : "";
        wcCell.style.padding = "6px 4px";
        tr.appendChild(wcCell);

        const rawCell = document.createElement("td");
        rawCell.textContent = (data.counts_raw && data.counts_raw[i]!==undefined) ? data.counts_raw[i] : 0;
        rawCell.style.padding = "6px 4px";
        tr.appendChild(rawCell);

        if (normalize) {
          const normCell = document.createElement("td");
          normCell.textContent = (data.counts_norm && data.counts_norm[i]!==undefined && data.counts_norm[i] !== null) ? Number(data.counts_norm[i]).toFixed(2) : "";
          normCell.style.padding = "6px 4px";
          tr.appendChild(normCell);
        }

        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      report.appendChild(table);
    } else {
      const p2 = document.createElement("p");
      p2.textContent = "No numeric data available for this query.";
      report.appendChild(p2);
    }

    statusEl.textContent = "Status: done.";
    // Optionally focus the image so keyboard / screen reader users find it quickly:
    // img.focus();

  } catch (err) {
    console.error("Error during plot:", err);
    let msg = String(err);
    statusEl.textContent = "Status: error during plotting — see console. " + (msg.split("\n")[0] || "");
    plotEl.innerHTML = "<pre style='color:red'>Error: " + (msg.split('\n')[0] || msg) + "</pre>";
  }
}

// ---------- UI wiring ----------
plotBtn.addEventListener("click", () => {
  const q = lemmaInput.value.trim();
  if (!q) { alert("Enter a lemmatized single word (e.g., 'vampire')."); return; }
  plotLemma(q, normalizeBox.checked);
});
lemmaInput.addEventListener("keydown", (e) => { if (e.key === "Enter") plotBtn.click(); });

</script>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
    tabsets.forEach(function(tabset) {
      const tabby = new Tabby('#' + tabset.id);
    });
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/iulibscholcomm\.github\.io\/dracula\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./99-text-analysis.html" class="pagination-link" aria-label="Text analysis: Dracula">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Text analysis: Dracula</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->




<script src="site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>