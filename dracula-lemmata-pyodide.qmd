---
title: "Dracula — Lemmatized Term-Frequency (Pyodide + precomputed chap_lemmas.csv)"
format: html
execute:
  echo: false
  enabled: true
---
<div style="max-width:900px">
  <p>Enter a single **lemmatized** word (no multi-word phrases). Example: <code>vampire</code></p>

  <label for="lemma">Lemma:</label>
  <input id="lemma" placeholder="vampire" style="width:220px" />
  <button id="plotBtn">Plot</button>
  <label style="margin-left:12px"><input type="checkbox" id="normalize" /> Normalize (per 1k words)</label>

  <div id="status" style="margin-top:8px;color:#666">Status: initializing...</div>
  <div id="plotArea" style="margin-top:12px"></div>

  <p style="color:#666; margin-top:14px; font-size:0.95em">
    If you want full spaCy-powered searches or NER, run the original notebook in Binder/Colab; this page is designed for lightweight in-browser lemmatized lookups using a precomputed CSV.
  </p>
</div>

<script type="module">
/* Single unified Pyodide-powered script.
   - Replaces duplicate functions / states in your prior version.
   - Keeps pyState as an object { df_proxy, counters_proxy, source }.
*/

// Candidate CSV paths (replace/extend as you like)
const CSV_CANDIDATES = [
  "https://iulibscholcomm.github.io/dracula/data/chap_lemmas.csv",
  "/dracula/data/chap_lemmas.csv",
  "/data/chap_lemmas.csv",
  "data/chap_lemmas.csv",
  "chap_lemmas.csv"
];

const statusEl = document.getElementById("status");
const plotEl = document.getElementById("plotArea");
const plotBtn = document.getElementById("plotBtn");
const lemmaInput = document.getElementById("lemma");
const normalizeBox = document.getElementById("normalize");

let pyodide = null;
let pyReady = false;
let csvTextCache = null;
let pyState = null; // { df_proxy, counters_proxy, source }

// Python snippets used later
const initPyGlobals = `
import io, pandas as pd
from collections import Counter

# csv_text is injected by JS
if 'csv_text' not in globals() or csv_text is None:
    raise ValueError("csv_text not provided or is None.")

# Read CSV robustly
try:
    df = pd.read_csv(io.StringIO(csv_text), encoding='utf-8')
except Exception as e:
    preview = (csv_text or "")[:1000]
    raise ValueError(f"pd.read_csv failed: {e}\\nPreview (first 1000 chars):\\n{preview}")

# Validate minimal columns
required = ['chapter','lemmas_str','word_count']
missing = [c for c in required if c not in df.columns]
if missing:
    raise ValueError("Missing columns in chap_lemmas.csv: " + ",".join(missing))

# Normalize types and fillna
df['chapter'] = pd.to_numeric(df['chapter'], errors='coerce').fillna(0).astype(int)
df['lemmas_str'] = df.get('lemmas_str', '').fillna("").astype(str)
df['word_count'] = pd.to_numeric(df.get('word_count', 0), errors='coerce').fillna(0).astype(int)

# Build counters per row
chapter_counters = []
for s in df['lemmas_str'].tolist():
    if not s:
        chapter_counters.append(Counter())
    else:
        chapter_counters.append(Counter(s.split()))

# Expose to JS via pyodide.globals
chap_df = df
chapter_counters = chapter_counters

# readiness
"OK"
`;

const plotPyTemplate = `
import io, base64, matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np

# injected by JS: df, counters, query, normalize_flag
q = query.strip().lower()
if not q:
    raise ValueError("Empty query")

# counters is expected to be an iterable of Counter objects
try:
    counts = [c.get(q, 0) for c in counters]
except Exception as e:
    raise ValueError("Error iterating counters: " + str(e))

lengths = df['word_count'].tolist()
arr = np.array(counts, dtype=float)
if normalize_flag:
    lens = np.array(lengths, dtype=float)
    lens[lens==0] = 1.0
    arr = arr / lens * 1000.0

x = np.arange(1, len(arr)+1)
fig, ax = plt.subplots(figsize=(9,3))
ax.plot(x, arr, marker='o', linewidth=1)
ax.set_xlabel("Chapter")
ax.set_ylabel("Occurrences per 1k words" if normalize_flag else "Raw count")
ax.set_title(f"Frequency of '{query}' (lemmatized) — n_chapters={len(arr)}")
ax.grid(axis='y', alpha=0.3)
plt.tight_layout()
buf = io.BytesIO()
fig.savefig(buf, format='png', dpi=150)
plt.close(fig)
buf.seek(0)
base64.b64encode(buf.getvalue()).decode('ascii')
`;

// ---------- Helpers ----------
async function loadPy() {
  statusEl.textContent = "Status: loading Pyodide (may take a few seconds)...";
  if (typeof loadPyodide !== "function") {
    const s = document.createElement("script");
    s.src = "https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js";
    document.head.appendChild(s);
    await new Promise(res => { s.onload = res; });
  }
  pyodide = await loadPyodide({ indexURL: "https://cdn.jsdelivr.net/pyodide/v0.23.4/full/" });
  statusEl.textContent = "Status: installing micropip & packages...";
  await pyodide.loadPackage(["micropip"]);
  const micropip = pyodide.pyimport("micropip");
  // install pandas & matplotlib (pyodide wheels)
  await micropip.install("pandas");
  await micropip.install("matplotlib");
  // ensure numpy is available as well
  await pyodide.loadPackage(["numpy"]);
  statusEl.textContent = "Status: Python environment ready.";
  pyReady = true;
}

async function tryFetchCandidates(candidates) {
  for (const url of candidates) {
    statusEl.textContent = `Status: attempting to fetch ${url} ...`;
    try {
      const r = await fetch(url);
      if (!r.ok) {
        console.debug(`Candidate ${url} returned ${r.status}`);
        continue;
      }
      const txt = await r.text();
      statusEl.textContent = `Status: loaded ${url}`;
      return { url, text: txt };
    } catch (e) {
      console.debug(`Fetch ${url} failed:`, e);
      continue;
    }
  }
  throw new Error("All CSV fetch attempts failed.");
}

// ---------- Initialization sequence ----------
(async () => {
  try {
    await loadPy();
  } catch (err) {
    console.error("Pyodide load failed:", err);
    statusEl.textContent = "Status: Pyodide load failed: " + String(err);
    return;
  }

  // fetch CSV text
  let csvResult = null;
  try {
    csvResult = await tryFetchCandidates(CSV_CANDIDATES);
  } catch (fetchErr) {
    console.error("CSV fetch attempts failed:", fetchErr);
    statusEl.textContent = "Status: failed to fetch chap_lemmas.csv. Place file under docs/data and/or update CSV_CANDIDATES.";
    return;
  }

  csvTextCache = csvResult.text || "";
  statusEl.textContent = `Status: building Python state from ${csvResult.url}...`;

  try {
    // inject csv_text into Python globals and run initialization
    pyodide.globals.set("csv_text", csvTextCache);
    const ok = await pyodide.runPythonAsync(initPyGlobals);
    // remove csv_text to free memory
    try { pyodide.globals.delete("csv_text"); } catch (e) {}
    if (ok !== "OK") {
      console.warn("Python init returned:", ok);
    }

    // extract proxies
    const py_df = pyodide.globals.get("chap_df");
    const py_counters = pyodide.globals.get("chapter_counters");

    if (!py_df || !py_counters) {
      console.error("Missing Python globals after init:", { py_df, py_counters });
      statusEl.textContent = "Status: Python init failed — chap_df or chapter_counters not set. See console.";
      return;
    }

    pyState = { df_proxy: py_df, counters_proxy: py_counters, source: csvResult.url };
    statusEl.textContent = `Status: ready (using ${csvResult.url}). Enter a lemmatized word and click Plot.`;
  } catch (pyErr) {
    console.error("Python initialization error:", pyErr);
    try { console.warn("CSV preview (first 800 chars):", (csvTextCache||"").slice(0,800)); } catch(e){}
    statusEl.textContent = "Status: Python initialization failed — see console for details.";
    return;
  }
})();

// ---------- Single canonical plotting function ----------
async function plotLemma(query, normalize) {
  if (!pyReady) {
    statusEl.textContent = "Status: Pyodide not ready.";
    return;
  }
  if (!pyState || !pyState.df_proxy || !pyState.counters_proxy) {
    statusEl.textContent = "Status: Python state not initialized. Try reloading the page.";
    console.error("plotLemma called but pyState is missing or malformed:", pyState);
    return;
  }

  statusEl.textContent = "Status: computing counts & plotting...";
  try {
    // inject handles expected by plot template
    pyodide.globals.set("df", pyState.df_proxy);
    pyodide.globals.set("counters", pyState.counters_proxy);
    pyodide.globals.set("query", query);
    pyodide.globals.set("normalize_flag", normalize);

    const b64 = await pyodide.runPythonAsync(plotPyTemplate);

    // cleanup injected globals to avoid accidental reuse / memory growth
    try { pyodide.globals.delete("df"); } catch(e){}
    try { pyodide.globals.delete("counters"); } catch(e){}
    try { pyodide.globals.delete("query"); } catch(e){}
    try { pyodide.globals.delete("normalize_flag"); } catch(e){}

    // render image
    plotEl.innerHTML = "";
    const img = document.createElement("img");
    img.src = "data:image/png;base64," + b64;
    img.alt = `Lemma frequency: ${query}`;
    img.style.maxWidth = "100%";
    plotEl.appendChild(img);
    statusEl.textContent = "Status: done.";
  } catch (err) {
    console.error("Error during plot:", err);
    // provide concise user-facing message, details in console
    let msg = String(err);
    statusEl.textContent = "Status: error during plotting — see console. " + (msg.split("\\n")[0] || "");
    plotEl.innerHTML = "<pre style='color:red'>Error: " + (msg.split('\\n')[0] || msg) + "</pre>";
  }
}

// ---------- UI wiring (single copy) ----------
plotBtn.addEventListener("click", () => {
  const q = lemmaInput.value.trim();
  if (!q) { alert("Enter a lemmatized single word (e.g., 'vampire')."); return; }
  plotLemma(q, normalizeBox.checked);
});
lemmaInput.addEventListener("keydown", (e) => { if (e.key === "Enter") plotBtn.click(); });

</script>
